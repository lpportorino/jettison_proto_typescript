// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v5.29.2
// source: jon_sych_archive.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { VideoMeta } from "./jon_video_meta";

/**
 * Archive index - always the last entry in .sych_video tar file.
 * The archive ends with an 8-byte footer:
 * where block count indicates how many 1MB blocks contain the index.
 */
export interface SychArchiveIndex {
  /** Format version (currently 1) */
  version: number;
  /** Unix timestamp when archive was created */
  createdAt: Long;
  /** Origin URL for "go online" link (e.g., "https://sych.local") */
  exportedFrom: string;
  /** File index with byte offsets for direct seeking */
  files: ArchiveEntry[];
  /** Timeline data with embedded video metadata */
  timeline:
    | TimelineIndex
    | undefined;
  /** OSD reference (paths within archive) - optional */
  osd?: OSDReference | undefined;
}

/** Entry in the archive file index, used for direct seeking to files */
export interface ArchiveEntry {
  /** Path within tar (e.g., "videos/001_abc.mp4") */
  path: string;
  /** Byte offset of tar header in archive */
  headerOffset: Long;
  /** Byte offset of file content (header_offset + 512) */
  dataOffset: Long;
  /** File size in bytes */
  size: Long;
}

/** Timeline index containing video entries with embedded metadata */
export interface TimelineIndex {
  /** Total frame count across all videos */
  totalFrames: number;
  /** Total duration in milliseconds */
  totalDurationMs: number;
  /** Video entries in playback order */
  videos: VideoEntry[];
}

/** Video entry with embedded metadata from jon_video_meta.proto */
export interface VideoEntry {
  /** Original video ID (video:session:uuid format) */
  id: string;
  /** Path in archive (e.g., "videos/001_abc.mp4") */
  archivePath: string;
  /** Thumbnail path in archive (optional, e.g., "thumbnails/001_abc.png") */
  thumbnailPath?:
    | string
    | undefined;
  /** Start frame in global timeline */
  globalFrameStart: number;
  /** Embedded video metadata including sample table for frame-accurate seeking */
  meta: VideoMeta | undefined;
}

/** Reference to OSD package and config within the archive */
export interface OSDReference {
  /** Path to OSD package tar within archive (e.g., "osd/package.tar") */
  packagePath: string;
  /** Path to OSD config JSON within archive (e.g., "osd/config.json") */
  configPath: string;
  /** Package metadata */
  packageName: string;
  packageVersion: string;
  /** Package variant (only recording_day supported for offline playback) */
  packageVariant: string;
}

function createBaseSychArchiveIndex(): SychArchiveIndex {
  return { version: 0, createdAt: Long.UZERO, exportedFrom: "", files: [], timeline: undefined, osd: undefined };
}

export const SychArchiveIndex: MessageFns<SychArchiveIndex> = {
  encode(message: SychArchiveIndex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (!message.createdAt.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.createdAt.toString());
    }
    if (message.exportedFrom !== "") {
      writer.uint32(26).string(message.exportedFrom);
    }
    for (const v of message.files) {
      ArchiveEntry.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.timeline !== undefined) {
      TimelineIndex.encode(message.timeline, writer.uint32(42).fork()).join();
    }
    if (message.osd !== undefined) {
      OSDReference.encode(message.osd, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SychArchiveIndex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSychArchiveIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.createdAt = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.exportedFrom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.files.push(ArchiveEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timeline = TimelineIndex.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.osd = OSDReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SychArchiveIndex {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      createdAt: isSet(object.createdAt) ? Long.fromValue(object.createdAt) : Long.UZERO,
      exportedFrom: isSet(object.exportedFrom) ? globalThis.String(object.exportedFrom) : "",
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => ArchiveEntry.fromJSON(e)) : [],
      timeline: isSet(object.timeline) ? TimelineIndex.fromJSON(object.timeline) : undefined,
      osd: isSet(object.osd) ? OSDReference.fromJSON(object.osd) : undefined,
    };
  },

  toJSON(message: SychArchiveIndex): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (!message.createdAt.equals(Long.UZERO)) {
      obj.createdAt = (message.createdAt || Long.UZERO).toString();
    }
    if (message.exportedFrom !== "") {
      obj.exportedFrom = message.exportedFrom;
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => ArchiveEntry.toJSON(e));
    }
    if (message.timeline !== undefined) {
      obj.timeline = TimelineIndex.toJSON(message.timeline);
    }
    if (message.osd !== undefined) {
      obj.osd = OSDReference.toJSON(message.osd);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SychArchiveIndex>, I>>(base?: I): SychArchiveIndex {
    return SychArchiveIndex.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SychArchiveIndex>, I>>(object: I): SychArchiveIndex {
    const message = createBaseSychArchiveIndex();
    message.version = object.version ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.UZERO;
    message.exportedFrom = object.exportedFrom ?? "";
    message.files = object.files?.map((e) => ArchiveEntry.fromPartial(e)) || [];
    message.timeline = (object.timeline !== undefined && object.timeline !== null)
      ? TimelineIndex.fromPartial(object.timeline)
      : undefined;
    message.osd = (object.osd !== undefined && object.osd !== null) ? OSDReference.fromPartial(object.osd) : undefined;
    return message;
  },
};

function createBaseArchiveEntry(): ArchiveEntry {
  return { path: "", headerOffset: Long.UZERO, dataOffset: Long.UZERO, size: Long.UZERO };
}

export const ArchiveEntry: MessageFns<ArchiveEntry> = {
  encode(message: ArchiveEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (!message.headerOffset.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.headerOffset.toString());
    }
    if (!message.dataOffset.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.dataOffset.toString());
    }
    if (!message.size.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.size.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArchiveEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArchiveEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.headerOffset = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.dataOffset = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.size = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArchiveEntry {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      headerOffset: isSet(object.headerOffset) ? Long.fromValue(object.headerOffset) : Long.UZERO,
      dataOffset: isSet(object.dataOffset) ? Long.fromValue(object.dataOffset) : Long.UZERO,
      size: isSet(object.size) ? Long.fromValue(object.size) : Long.UZERO,
    };
  },

  toJSON(message: ArchiveEntry): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (!message.headerOffset.equals(Long.UZERO)) {
      obj.headerOffset = (message.headerOffset || Long.UZERO).toString();
    }
    if (!message.dataOffset.equals(Long.UZERO)) {
      obj.dataOffset = (message.dataOffset || Long.UZERO).toString();
    }
    if (!message.size.equals(Long.UZERO)) {
      obj.size = (message.size || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArchiveEntry>, I>>(base?: I): ArchiveEntry {
    return ArchiveEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArchiveEntry>, I>>(object: I): ArchiveEntry {
    const message = createBaseArchiveEntry();
    message.path = object.path ?? "";
    message.headerOffset = (object.headerOffset !== undefined && object.headerOffset !== null)
      ? Long.fromValue(object.headerOffset)
      : Long.UZERO;
    message.dataOffset = (object.dataOffset !== undefined && object.dataOffset !== null)
      ? Long.fromValue(object.dataOffset)
      : Long.UZERO;
    message.size = (object.size !== undefined && object.size !== null) ? Long.fromValue(object.size) : Long.UZERO;
    return message;
  },
};

function createBaseTimelineIndex(): TimelineIndex {
  return { totalFrames: 0, totalDurationMs: 0, videos: [] };
}

export const TimelineIndex: MessageFns<TimelineIndex> = {
  encode(message: TimelineIndex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalFrames !== 0) {
      writer.uint32(8).uint32(message.totalFrames);
    }
    if (message.totalDurationMs !== 0) {
      writer.uint32(16).uint32(message.totalDurationMs);
    }
    for (const v of message.videos) {
      VideoEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimelineIndex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimelineIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalFrames = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalDurationMs = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.videos.push(VideoEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimelineIndex {
    return {
      totalFrames: isSet(object.totalFrames) ? globalThis.Number(object.totalFrames) : 0,
      totalDurationMs: isSet(object.totalDurationMs) ? globalThis.Number(object.totalDurationMs) : 0,
      videos: globalThis.Array.isArray(object?.videos) ? object.videos.map((e: any) => VideoEntry.fromJSON(e)) : [],
    };
  },

  toJSON(message: TimelineIndex): unknown {
    const obj: any = {};
    if (message.totalFrames !== 0) {
      obj.totalFrames = Math.round(message.totalFrames);
    }
    if (message.totalDurationMs !== 0) {
      obj.totalDurationMs = Math.round(message.totalDurationMs);
    }
    if (message.videos?.length) {
      obj.videos = message.videos.map((e) => VideoEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimelineIndex>, I>>(base?: I): TimelineIndex {
    return TimelineIndex.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimelineIndex>, I>>(object: I): TimelineIndex {
    const message = createBaseTimelineIndex();
    message.totalFrames = object.totalFrames ?? 0;
    message.totalDurationMs = object.totalDurationMs ?? 0;
    message.videos = object.videos?.map((e) => VideoEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVideoEntry(): VideoEntry {
  return { id: "", archivePath: "", thumbnailPath: undefined, globalFrameStart: 0, meta: undefined };
}

export const VideoEntry: MessageFns<VideoEntry> = {
  encode(message: VideoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.archivePath !== "") {
      writer.uint32(18).string(message.archivePath);
    }
    if (message.thumbnailPath !== undefined) {
      writer.uint32(26).string(message.thumbnailPath);
    }
    if (message.globalFrameStart !== 0) {
      writer.uint32(32).uint32(message.globalFrameStart);
    }
    if (message.meta !== undefined) {
      VideoMeta.encode(message.meta, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.archivePath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thumbnailPath = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.globalFrameStart = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.meta = VideoMeta.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoEntry {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      archivePath: isSet(object.archivePath) ? globalThis.String(object.archivePath) : "",
      thumbnailPath: isSet(object.thumbnailPath) ? globalThis.String(object.thumbnailPath) : undefined,
      globalFrameStart: isSet(object.globalFrameStart) ? globalThis.Number(object.globalFrameStart) : 0,
      meta: isSet(object.meta) ? VideoMeta.fromJSON(object.meta) : undefined,
    };
  },

  toJSON(message: VideoEntry): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.archivePath !== "") {
      obj.archivePath = message.archivePath;
    }
    if (message.thumbnailPath !== undefined) {
      obj.thumbnailPath = message.thumbnailPath;
    }
    if (message.globalFrameStart !== 0) {
      obj.globalFrameStart = Math.round(message.globalFrameStart);
    }
    if (message.meta !== undefined) {
      obj.meta = VideoMeta.toJSON(message.meta);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoEntry>, I>>(base?: I): VideoEntry {
    return VideoEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoEntry>, I>>(object: I): VideoEntry {
    const message = createBaseVideoEntry();
    message.id = object.id ?? "";
    message.archivePath = object.archivePath ?? "";
    message.thumbnailPath = object.thumbnailPath ?? undefined;
    message.globalFrameStart = object.globalFrameStart ?? 0;
    message.meta = (object.meta !== undefined && object.meta !== null) ? VideoMeta.fromPartial(object.meta) : undefined;
    return message;
  },
};

function createBaseOSDReference(): OSDReference {
  return { packagePath: "", configPath: "", packageName: "", packageVersion: "", packageVariant: "" };
}

export const OSDReference: MessageFns<OSDReference> = {
  encode(message: OSDReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packagePath !== "") {
      writer.uint32(10).string(message.packagePath);
    }
    if (message.configPath !== "") {
      writer.uint32(18).string(message.configPath);
    }
    if (message.packageName !== "") {
      writer.uint32(26).string(message.packageName);
    }
    if (message.packageVersion !== "") {
      writer.uint32(34).string(message.packageVersion);
    }
    if (message.packageVariant !== "") {
      writer.uint32(42).string(message.packageVariant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OSDReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOSDReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packagePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.configPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.packageName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.packageVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.packageVariant = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OSDReference {
    return {
      packagePath: isSet(object.packagePath) ? globalThis.String(object.packagePath) : "",
      configPath: isSet(object.configPath) ? globalThis.String(object.configPath) : "",
      packageName: isSet(object.packageName) ? globalThis.String(object.packageName) : "",
      packageVersion: isSet(object.packageVersion) ? globalThis.String(object.packageVersion) : "",
      packageVariant: isSet(object.packageVariant) ? globalThis.String(object.packageVariant) : "",
    };
  },

  toJSON(message: OSDReference): unknown {
    const obj: any = {};
    if (message.packagePath !== "") {
      obj.packagePath = message.packagePath;
    }
    if (message.configPath !== "") {
      obj.configPath = message.configPath;
    }
    if (message.packageName !== "") {
      obj.packageName = message.packageName;
    }
    if (message.packageVersion !== "") {
      obj.packageVersion = message.packageVersion;
    }
    if (message.packageVariant !== "") {
      obj.packageVariant = message.packageVariant;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OSDReference>, I>>(base?: I): OSDReference {
    return OSDReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OSDReference>, I>>(object: I): OSDReference {
    const message = createBaseOSDReference();
    message.packagePath = object.packagePath ?? "";
    message.configPath = object.configPath ?? "";
    message.packageName = object.packageName ?? "";
    message.packageVersion = object.packageVersion ?? "";
    message.packageVariant = object.packageVariant ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
