// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v5.29.2
// source: jon_video_meta.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

/** Types of errors that can occur during video metadata extraction */
export enum VideoErrorType {
  VIDEO_ERROR_TYPE_UNSPECIFIED = 0,
  VIDEO_ERROR_TYPE_FILE_NOT_FOUND = 1,
  VIDEO_ERROR_TYPE_EMPTY_FILE = 2,
  VIDEO_ERROR_TYPE_NO_MOOV = 3,
  VIDEO_ERROR_TYPE_INVALID_MOOV = 4,
  VIDEO_ERROR_TYPE_TRUNCATED = 5,
  UNRECOGNIZED = -1,
}

export function videoErrorTypeFromJSON(object: any): VideoErrorType {
  switch (object) {
    case 0:
    case "VIDEO_ERROR_TYPE_UNSPECIFIED":
      return VideoErrorType.VIDEO_ERROR_TYPE_UNSPECIFIED;
    case 1:
    case "VIDEO_ERROR_TYPE_FILE_NOT_FOUND":
      return VideoErrorType.VIDEO_ERROR_TYPE_FILE_NOT_FOUND;
    case 2:
    case "VIDEO_ERROR_TYPE_EMPTY_FILE":
      return VideoErrorType.VIDEO_ERROR_TYPE_EMPTY_FILE;
    case 3:
    case "VIDEO_ERROR_TYPE_NO_MOOV":
      return VideoErrorType.VIDEO_ERROR_TYPE_NO_MOOV;
    case 4:
    case "VIDEO_ERROR_TYPE_INVALID_MOOV":
      return VideoErrorType.VIDEO_ERROR_TYPE_INVALID_MOOV;
    case 5:
    case "VIDEO_ERROR_TYPE_TRUNCATED":
      return VideoErrorType.VIDEO_ERROR_TYPE_TRUNCATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VideoErrorType.UNRECOGNIZED;
  }
}

export function videoErrorTypeToJSON(object: VideoErrorType): string {
  switch (object) {
    case VideoErrorType.VIDEO_ERROR_TYPE_UNSPECIFIED:
      return "VIDEO_ERROR_TYPE_UNSPECIFIED";
    case VideoErrorType.VIDEO_ERROR_TYPE_FILE_NOT_FOUND:
      return "VIDEO_ERROR_TYPE_FILE_NOT_FOUND";
    case VideoErrorType.VIDEO_ERROR_TYPE_EMPTY_FILE:
      return "VIDEO_ERROR_TYPE_EMPTY_FILE";
    case VideoErrorType.VIDEO_ERROR_TYPE_NO_MOOV:
      return "VIDEO_ERROR_TYPE_NO_MOOV";
    case VideoErrorType.VIDEO_ERROR_TYPE_INVALID_MOOV:
      return "VIDEO_ERROR_TYPE_INVALID_MOOV";
    case VideoErrorType.VIDEO_ERROR_TYPE_TRUNCATED:
      return "VIDEO_ERROR_TYPE_TRUNCATED";
    case VideoErrorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for video metadata retrieval */
export interface VideoMetaRequest {
  /** Time-based range query */
  range?:
    | VideoRangeQuery
    | undefined;
  /** Explicit UUID list */
  ids?: VideoIdList | undefined;
}

/** List of video UUIDs for explicit selection */
export interface VideoIdList {
  uuids: string[];
}

/** Time-based range query for selecting videos */
export interface VideoRangeQuery {
  /** Unix seconds */
  startTimestamp: Long;
  /** Unix seconds */
  endTimestamp: Long;
  /** "day" or "heat" filter */
  sourceType?: string | undefined;
  limit?:
    | number
    | undefined;
  /** Pagination offset */
  offset?: number | undefined;
}

/** Response containing video metadata and any errors */
export interface VideoMetaResponse {
  /** Successfully processed videos */
  videos: VideoMeta[];
  /** Errors for failed videos */
  errors: VideoError[];
  /** Total matching (before limit) */
  totalCount: number;
}

/** Metadata for a single video including MOOV data */
export interface VideoMeta {
  uuid: string;
  sessionId: number;
  /** Unix seconds */
  timestamp: Long;
  /** Directory path to video files */
  storagePath: string;
  /** "day" or "heat" */
  sourceType: string;
  /** MOOV extracted data */
  frameCount: number;
  durationMs: number;
  width: number;
  height: number;
  /** avcC decoder specific info */
  dsi: Uint8Array;
  /** Media timescale from mdhd */
  timescale: number;
  /** Sample table (always included for playback) */
  sampleTable: SampleTable | undefined;
}

/** MP4 sample table data extracted from MOOV */
export interface SampleTable {
  /** Frame sizes in bytes (stsz) */
  sampleSizes: number[];
  /** Byte offsets in file (stco/co64) */
  chunkOffsets: Long[];
  /** Decoding timestamps (stts deltas) */
  sampleTimes: number[];
  /** Keyframe indices, 1-based (stss) */
  syncSamples: number[];
  /** Sample-to-chunk mapping (stsc) */
  sampleToChunk: SampleToChunk[];
}

/** Sample-to-chunk box entry */
export interface SampleToChunk {
  firstChunk: number;
  samplesPerChunk: number;
  sampleDescriptionIndex: number;
}

/** Error information for a video that failed processing */
export interface VideoError {
  uuid: string;
  storagePath: string;
  errorType: VideoErrorType;
  errorMessage: string;
}

function createBaseVideoMetaRequest(): VideoMetaRequest {
  return { range: undefined, ids: undefined };
}

export const VideoMetaRequest: MessageFns<VideoMetaRequest> = {
  encode(message: VideoMetaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.range !== undefined) {
      VideoRangeQuery.encode(message.range, writer.uint32(10).fork()).join();
    }
    if (message.ids !== undefined) {
      VideoIdList.encode(message.ids, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoMetaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoMetaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.range = VideoRangeQuery.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ids = VideoIdList.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoMetaRequest {
    return {
      range: isSet(object.range) ? VideoRangeQuery.fromJSON(object.range) : undefined,
      ids: isSet(object.ids) ? VideoIdList.fromJSON(object.ids) : undefined,
    };
  },

  toJSON(message: VideoMetaRequest): unknown {
    const obj: any = {};
    if (message.range !== undefined) {
      obj.range = VideoRangeQuery.toJSON(message.range);
    }
    if (message.ids !== undefined) {
      obj.ids = VideoIdList.toJSON(message.ids);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoMetaRequest>, I>>(base?: I): VideoMetaRequest {
    return VideoMetaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoMetaRequest>, I>>(object: I): VideoMetaRequest {
    const message = createBaseVideoMetaRequest();
    message.range = (object.range !== undefined && object.range !== null)
      ? VideoRangeQuery.fromPartial(object.range)
      : undefined;
    message.ids = (object.ids !== undefined && object.ids !== null) ? VideoIdList.fromPartial(object.ids) : undefined;
    return message;
  },
};

function createBaseVideoIdList(): VideoIdList {
  return { uuids: [] };
}

export const VideoIdList: MessageFns<VideoIdList> = {
  encode(message: VideoIdList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.uuids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoIdList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoIdList {
    return { uuids: globalThis.Array.isArray(object?.uuids) ? object.uuids.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: VideoIdList): unknown {
    const obj: any = {};
    if (message.uuids?.length) {
      obj.uuids = message.uuids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoIdList>, I>>(base?: I): VideoIdList {
    return VideoIdList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoIdList>, I>>(object: I): VideoIdList {
    const message = createBaseVideoIdList();
    message.uuids = object.uuids?.map((e) => e) || [];
    return message;
  },
};

function createBaseVideoRangeQuery(): VideoRangeQuery {
  return {
    startTimestamp: Long.UZERO,
    endTimestamp: Long.UZERO,
    sourceType: undefined,
    limit: undefined,
    offset: undefined,
  };
}

export const VideoRangeQuery: MessageFns<VideoRangeQuery> = {
  encode(message: VideoRangeQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.startTimestamp.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.startTimestamp.toString());
    }
    if (!message.endTimestamp.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.endTimestamp.toString());
    }
    if (message.sourceType !== undefined) {
      writer.uint32(26).string(message.sourceType);
    }
    if (message.limit !== undefined) {
      writer.uint32(32).uint32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(40).uint32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoRangeQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoRangeQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startTimestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.endTimestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoRangeQuery {
    return {
      startTimestamp: isSet(object.startTimestamp) ? Long.fromValue(object.startTimestamp) : Long.UZERO,
      endTimestamp: isSet(object.endTimestamp) ? Long.fromValue(object.endTimestamp) : Long.UZERO,
      sourceType: isSet(object.sourceType) ? globalThis.String(object.sourceType) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : undefined,
    };
  },

  toJSON(message: VideoRangeQuery): unknown {
    const obj: any = {};
    if (!message.startTimestamp.equals(Long.UZERO)) {
      obj.startTimestamp = (message.startTimestamp || Long.UZERO).toString();
    }
    if (!message.endTimestamp.equals(Long.UZERO)) {
      obj.endTimestamp = (message.endTimestamp || Long.UZERO).toString();
    }
    if (message.sourceType !== undefined) {
      obj.sourceType = message.sourceType;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== undefined) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoRangeQuery>, I>>(base?: I): VideoRangeQuery {
    return VideoRangeQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoRangeQuery>, I>>(object: I): VideoRangeQuery {
    const message = createBaseVideoRangeQuery();
    message.startTimestamp = (object.startTimestamp !== undefined && object.startTimestamp !== null)
      ? Long.fromValue(object.startTimestamp)
      : Long.UZERO;
    message.endTimestamp = (object.endTimestamp !== undefined && object.endTimestamp !== null)
      ? Long.fromValue(object.endTimestamp)
      : Long.UZERO;
    message.sourceType = object.sourceType ?? undefined;
    message.limit = object.limit ?? undefined;
    message.offset = object.offset ?? undefined;
    return message;
  },
};

function createBaseVideoMetaResponse(): VideoMetaResponse {
  return { videos: [], errors: [], totalCount: 0 };
}

export const VideoMetaResponse: MessageFns<VideoMetaResponse> = {
  encode(message: VideoMetaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.videos) {
      VideoMeta.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.errors) {
      VideoError.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(24).uint32(message.totalCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoMetaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoMetaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videos.push(VideoMeta.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errors.push(VideoError.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoMetaResponse {
    return {
      videos: globalThis.Array.isArray(object?.videos) ? object.videos.map((e: any) => VideoMeta.fromJSON(e)) : [],
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => VideoError.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: VideoMetaResponse): unknown {
    const obj: any = {};
    if (message.videos?.length) {
      obj.videos = message.videos.map((e) => VideoMeta.toJSON(e));
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => VideoError.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoMetaResponse>, I>>(base?: I): VideoMetaResponse {
    return VideoMetaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoMetaResponse>, I>>(object: I): VideoMetaResponse {
    const message = createBaseVideoMetaResponse();
    message.videos = object.videos?.map((e) => VideoMeta.fromPartial(e)) || [];
    message.errors = object.errors?.map((e) => VideoError.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseVideoMeta(): VideoMeta {
  return {
    uuid: "",
    sessionId: 0,
    timestamp: Long.UZERO,
    storagePath: "",
    sourceType: "",
    frameCount: 0,
    durationMs: 0,
    width: 0,
    height: 0,
    dsi: new Uint8Array(0),
    timescale: 0,
    sampleTable: undefined,
  };
}

export const VideoMeta: MessageFns<VideoMeta> = {
  encode(message: VideoMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.sessionId !== 0) {
      writer.uint32(16).int32(message.sessionId);
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.timestamp.toString());
    }
    if (message.storagePath !== "") {
      writer.uint32(34).string(message.storagePath);
    }
    if (message.sourceType !== "") {
      writer.uint32(42).string(message.sourceType);
    }
    if (message.frameCount !== 0) {
      writer.uint32(48).uint32(message.frameCount);
    }
    if (message.durationMs !== 0) {
      writer.uint32(56).uint32(message.durationMs);
    }
    if (message.width !== 0) {
      writer.uint32(64).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(72).uint32(message.height);
    }
    if (message.dsi.length !== 0) {
      writer.uint32(82).bytes(message.dsi);
    }
    if (message.timescale !== 0) {
      writer.uint32(88).uint32(message.timescale);
    }
    if (message.sampleTable !== undefined) {
      SampleTable.encode(message.sampleTable, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.storagePath = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sourceType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.frameCount = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.durationMs = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.dsi = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.timescale = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.sampleTable = SampleTable.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoMeta {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.UZERO,
      storagePath: isSet(object.storagePath) ? globalThis.String(object.storagePath) : "",
      sourceType: isSet(object.sourceType) ? globalThis.String(object.sourceType) : "",
      frameCount: isSet(object.frameCount) ? globalThis.Number(object.frameCount) : 0,
      durationMs: isSet(object.durationMs) ? globalThis.Number(object.durationMs) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      dsi: isSet(object.dsi) ? bytesFromBase64(object.dsi) : new Uint8Array(0),
      timescale: isSet(object.timescale) ? globalThis.Number(object.timescale) : 0,
      sampleTable: isSet(object.sampleTable) ? SampleTable.fromJSON(object.sampleTable) : undefined,
    };
  },

  toJSON(message: VideoMeta): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      obj.timestamp = (message.timestamp || Long.UZERO).toString();
    }
    if (message.storagePath !== "") {
      obj.storagePath = message.storagePath;
    }
    if (message.sourceType !== "") {
      obj.sourceType = message.sourceType;
    }
    if (message.frameCount !== 0) {
      obj.frameCount = Math.round(message.frameCount);
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.dsi.length !== 0) {
      obj.dsi = base64FromBytes(message.dsi);
    }
    if (message.timescale !== 0) {
      obj.timescale = Math.round(message.timescale);
    }
    if (message.sampleTable !== undefined) {
      obj.sampleTable = SampleTable.toJSON(message.sampleTable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoMeta>, I>>(base?: I): VideoMeta {
    return VideoMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoMeta>, I>>(object: I): VideoMeta {
    const message = createBaseVideoMeta();
    message.uuid = object.uuid ?? "";
    message.sessionId = object.sessionId ?? 0;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.UZERO;
    message.storagePath = object.storagePath ?? "";
    message.sourceType = object.sourceType ?? "";
    message.frameCount = object.frameCount ?? 0;
    message.durationMs = object.durationMs ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.dsi = object.dsi ?? new Uint8Array(0);
    message.timescale = object.timescale ?? 0;
    message.sampleTable = (object.sampleTable !== undefined && object.sampleTable !== null)
      ? SampleTable.fromPartial(object.sampleTable)
      : undefined;
    return message;
  },
};

function createBaseSampleTable(): SampleTable {
  return { sampleSizes: [], chunkOffsets: [], sampleTimes: [], syncSamples: [], sampleToChunk: [] };
}

export const SampleTable: MessageFns<SampleTable> = {
  encode(message: SampleTable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.sampleSizes) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.chunkOffsets) {
      writer.uint64(v.toString());
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.sampleTimes) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.syncSamples) {
      writer.uint32(v);
    }
    writer.join();
    for (const v of message.sampleToChunk) {
      SampleToChunk.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SampleTable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSampleTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.sampleSizes.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.sampleSizes.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 16) {
            message.chunkOffsets.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.chunkOffsets.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag === 24) {
            message.sampleTimes.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.sampleTimes.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag === 32) {
            message.syncSamples.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.syncSamples.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sampleToChunk.push(SampleToChunk.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SampleTable {
    return {
      sampleSizes: globalThis.Array.isArray(object?.sampleSizes)
        ? object.sampleSizes.map((e: any) => globalThis.Number(e))
        : [],
      chunkOffsets: globalThis.Array.isArray(object?.chunkOffsets)
        ? object.chunkOffsets.map((e: any) => Long.fromValue(e))
        : [],
      sampleTimes: globalThis.Array.isArray(object?.sampleTimes)
        ? object.sampleTimes.map((e: any) => globalThis.Number(e))
        : [],
      syncSamples: globalThis.Array.isArray(object?.syncSamples)
        ? object.syncSamples.map((e: any) => globalThis.Number(e))
        : [],
      sampleToChunk: globalThis.Array.isArray(object?.sampleToChunk)
        ? object.sampleToChunk.map((e: any) => SampleToChunk.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SampleTable): unknown {
    const obj: any = {};
    if (message.sampleSizes?.length) {
      obj.sampleSizes = message.sampleSizes.map((e) => Math.round(e));
    }
    if (message.chunkOffsets?.length) {
      obj.chunkOffsets = message.chunkOffsets.map((e) => (e || Long.UZERO).toString());
    }
    if (message.sampleTimes?.length) {
      obj.sampleTimes = message.sampleTimes.map((e) => Math.round(e));
    }
    if (message.syncSamples?.length) {
      obj.syncSamples = message.syncSamples.map((e) => Math.round(e));
    }
    if (message.sampleToChunk?.length) {
      obj.sampleToChunk = message.sampleToChunk.map((e) => SampleToChunk.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SampleTable>, I>>(base?: I): SampleTable {
    return SampleTable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SampleTable>, I>>(object: I): SampleTable {
    const message = createBaseSampleTable();
    message.sampleSizes = object.sampleSizes?.map((e) => e) || [];
    message.chunkOffsets = object.chunkOffsets?.map((e) => Long.fromValue(e)) || [];
    message.sampleTimes = object.sampleTimes?.map((e) => e) || [];
    message.syncSamples = object.syncSamples?.map((e) => e) || [];
    message.sampleToChunk = object.sampleToChunk?.map((e) => SampleToChunk.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSampleToChunk(): SampleToChunk {
  return { firstChunk: 0, samplesPerChunk: 0, sampleDescriptionIndex: 0 };
}

export const SampleToChunk: MessageFns<SampleToChunk> = {
  encode(message: SampleToChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstChunk !== 0) {
      writer.uint32(8).uint32(message.firstChunk);
    }
    if (message.samplesPerChunk !== 0) {
      writer.uint32(16).uint32(message.samplesPerChunk);
    }
    if (message.sampleDescriptionIndex !== 0) {
      writer.uint32(24).uint32(message.sampleDescriptionIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SampleToChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSampleToChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.firstChunk = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.samplesPerChunk = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sampleDescriptionIndex = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SampleToChunk {
    return {
      firstChunk: isSet(object.firstChunk) ? globalThis.Number(object.firstChunk) : 0,
      samplesPerChunk: isSet(object.samplesPerChunk) ? globalThis.Number(object.samplesPerChunk) : 0,
      sampleDescriptionIndex: isSet(object.sampleDescriptionIndex)
        ? globalThis.Number(object.sampleDescriptionIndex)
        : 0,
    };
  },

  toJSON(message: SampleToChunk): unknown {
    const obj: any = {};
    if (message.firstChunk !== 0) {
      obj.firstChunk = Math.round(message.firstChunk);
    }
    if (message.samplesPerChunk !== 0) {
      obj.samplesPerChunk = Math.round(message.samplesPerChunk);
    }
    if (message.sampleDescriptionIndex !== 0) {
      obj.sampleDescriptionIndex = Math.round(message.sampleDescriptionIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SampleToChunk>, I>>(base?: I): SampleToChunk {
    return SampleToChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SampleToChunk>, I>>(object: I): SampleToChunk {
    const message = createBaseSampleToChunk();
    message.firstChunk = object.firstChunk ?? 0;
    message.samplesPerChunk = object.samplesPerChunk ?? 0;
    message.sampleDescriptionIndex = object.sampleDescriptionIndex ?? 0;
    return message;
  },
};

function createBaseVideoError(): VideoError {
  return { uuid: "", storagePath: "", errorType: 0, errorMessage: "" };
}

export const VideoError: MessageFns<VideoError> = {
  encode(message: VideoError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.storagePath !== "") {
      writer.uint32(18).string(message.storagePath);
    }
    if (message.errorType !== 0) {
      writer.uint32(24).int32(message.errorType);
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storagePath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.errorType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoError {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      storagePath: isSet(object.storagePath) ? globalThis.String(object.storagePath) : "",
      errorType: isSet(object.errorType) ? videoErrorTypeFromJSON(object.errorType) : 0,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: VideoError): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.storagePath !== "") {
      obj.storagePath = message.storagePath;
    }
    if (message.errorType !== 0) {
      obj.errorType = videoErrorTypeToJSON(message.errorType);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoError>, I>>(base?: I): VideoError {
    return VideoError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoError>, I>>(object: I): VideoError {
    const message = createBaseVideoError();
    message.uuid = object.uuid ?? "";
    message.storagePath = object.storagePath ?? "";
    message.errorType = object.errorType ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
