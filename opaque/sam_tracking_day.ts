// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.4
//   protoc               v5.29.2
// source: opaque/sam_tracking_day.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  SamTrackingFrameMeta,
  SamTrackingKalmanState,
  SamTrackingState,
  samTrackingStateFromJSON,
  samTrackingStateToJSON,
  SamTrackingStatus,
  samTrackingStatusFromJSON,
  samTrackingStatusToJSON,
} from "./sam_tracking_common";

/**
 * SAM visual tracking result for DAY camera channel.
 * Injected by bezoar SamTrackerModule into JonGUIState.opaque_payloads at inference rate (~30fps).
 * Contains RLE-encoded binary mask within the bounding box for efficient transmission.
 *
 * UUID: 019f4a7c-8b2d-7a1e-9c3f-2e8d5f1a4b6e
 */
export interface SamTrackingDay {
  /** Tracking status for this tick (required, must be valid enum value) */
  status: SamTrackingStatus;
  /** Current tracking state machine state */
  state: SamTrackingState;
  /**
   * Bounding box in NDC (Normalized Device Coordinates)
   * -1.0 (left/top) to 1.0 (right/bottom), center is (0,0)
   */
  bboxX1: number;
  bboxY1: number;
  bboxX2: number;
  bboxY2: number;
  /**
   * K-Medoids cluster center (centroid) in NDC
   * This is the point used to prompt the next iteration
   */
  centroidX: number;
  centroidY: number;
  /**
   * Tracking confidence
   * Computed as mask_area / bbox_area
   */
  confidence: number;
  /** Decoder IoU prediction */
  iou: number;
  /**
   * RLE-encoded binary mask within the bounding box
   * Format: ... (little-endian)
   * Max 64KB to prevent oversized payloads
   */
  maskRle: Uint8Array;
  /**
   * Mask dimensions within the bounding box (pixels)
   * Typically 256x256 from the SAM decoder output
   */
  maskWidth: number;
  maskHeight: number;
  /** Non-zero pixel count in the mask */
  maskPixels: number;
  /** Frame metadata for temporal correlation */
  frame:
    | SamTrackingFrameMeta
    | undefined;
  /** Kalman filter state for visualization/debugging */
  kalman:
    | SamTrackingKalmanState
    | undefined;
  /**
   * Number of consecutive frames in LOST state
   * Used for auto-stop logic (stop after 5 frames in LOST)
   */
  lostFrameCount: number;
  /** Processing latency (nanoseconds) */
  latencyNs: Long;
}

function createBaseSamTrackingDay(): SamTrackingDay {
  return {
    status: 0,
    state: 0,
    bboxX1: 0,
    bboxY1: 0,
    bboxX2: 0,
    bboxY2: 0,
    centroidX: 0,
    centroidY: 0,
    confidence: 0,
    iou: 0,
    maskRle: new Uint8Array(0),
    maskWidth: 0,
    maskHeight: 0,
    maskPixels: 0,
    frame: undefined,
    kalman: undefined,
    lostFrameCount: 0,
    latencyNs: Long.UZERO,
  };
}

export const SamTrackingDay: MessageFns<SamTrackingDay> = {
  encode(message: SamTrackingDay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.bboxX1 !== 0) {
      writer.uint32(25).double(message.bboxX1);
    }
    if (message.bboxY1 !== 0) {
      writer.uint32(33).double(message.bboxY1);
    }
    if (message.bboxX2 !== 0) {
      writer.uint32(41).double(message.bboxX2);
    }
    if (message.bboxY2 !== 0) {
      writer.uint32(49).double(message.bboxY2);
    }
    if (message.centroidX !== 0) {
      writer.uint32(57).double(message.centroidX);
    }
    if (message.centroidY !== 0) {
      writer.uint32(65).double(message.centroidY);
    }
    if (message.confidence !== 0) {
      writer.uint32(77).float(message.confidence);
    }
    if (message.iou !== 0) {
      writer.uint32(85).float(message.iou);
    }
    if (message.maskRle.length !== 0) {
      writer.uint32(90).bytes(message.maskRle);
    }
    if (message.maskWidth !== 0) {
      writer.uint32(96).uint32(message.maskWidth);
    }
    if (message.maskHeight !== 0) {
      writer.uint32(104).uint32(message.maskHeight);
    }
    if (message.maskPixels !== 0) {
      writer.uint32(112).uint32(message.maskPixels);
    }
    if (message.frame !== undefined) {
      SamTrackingFrameMeta.encode(message.frame, writer.uint32(122).fork()).join();
    }
    if (message.kalman !== undefined) {
      SamTrackingKalmanState.encode(message.kalman, writer.uint32(130).fork()).join();
    }
    if (message.lostFrameCount !== 0) {
      writer.uint32(136).uint32(message.lostFrameCount);
    }
    if (!message.latencyNs.equals(Long.UZERO)) {
      writer.uint32(144).uint64(message.latencyNs.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SamTrackingDay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSamTrackingDay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.bboxX1 = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.bboxY1 = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.bboxX2 = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.bboxY2 = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.centroidX = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.centroidY = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.confidence = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.iou = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.maskRle = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.maskWidth = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.maskHeight = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.maskPixels = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.frame = SamTrackingFrameMeta.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.kalman = SamTrackingKalmanState.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.lostFrameCount = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.latencyNs = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SamTrackingDay {
    return {
      status: isSet(object.status) ? samTrackingStatusFromJSON(object.status) : 0,
      state: isSet(object.state) ? samTrackingStateFromJSON(object.state) : 0,
      bboxX1: isSet(object.bboxX1)
        ? globalThis.Number(object.bboxX1)
        : isSet(object.bbox_x1)
        ? globalThis.Number(object.bbox_x1)
        : 0,
      bboxY1: isSet(object.bboxY1)
        ? globalThis.Number(object.bboxY1)
        : isSet(object.bbox_y1)
        ? globalThis.Number(object.bbox_y1)
        : 0,
      bboxX2: isSet(object.bboxX2)
        ? globalThis.Number(object.bboxX2)
        : isSet(object.bbox_x2)
        ? globalThis.Number(object.bbox_x2)
        : 0,
      bboxY2: isSet(object.bboxY2)
        ? globalThis.Number(object.bboxY2)
        : isSet(object.bbox_y2)
        ? globalThis.Number(object.bbox_y2)
        : 0,
      centroidX: isSet(object.centroidX)
        ? globalThis.Number(object.centroidX)
        : isSet(object.centroid_x)
        ? globalThis.Number(object.centroid_x)
        : 0,
      centroidY: isSet(object.centroidY)
        ? globalThis.Number(object.centroidY)
        : isSet(object.centroid_y)
        ? globalThis.Number(object.centroid_y)
        : 0,
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      iou: isSet(object.iou) ? globalThis.Number(object.iou) : 0,
      maskRle: isSet(object.maskRle)
        ? bytesFromBase64(object.maskRle)
        : isSet(object.mask_rle)
        ? bytesFromBase64(object.mask_rle)
        : new Uint8Array(0),
      maskWidth: isSet(object.maskWidth)
        ? globalThis.Number(object.maskWidth)
        : isSet(object.mask_width)
        ? globalThis.Number(object.mask_width)
        : 0,
      maskHeight: isSet(object.maskHeight)
        ? globalThis.Number(object.maskHeight)
        : isSet(object.mask_height)
        ? globalThis.Number(object.mask_height)
        : 0,
      maskPixels: isSet(object.maskPixels)
        ? globalThis.Number(object.maskPixels)
        : isSet(object.mask_pixels)
        ? globalThis.Number(object.mask_pixels)
        : 0,
      frame: isSet(object.frame) ? SamTrackingFrameMeta.fromJSON(object.frame) : undefined,
      kalman: isSet(object.kalman) ? SamTrackingKalmanState.fromJSON(object.kalman) : undefined,
      lostFrameCount: isSet(object.lostFrameCount)
        ? globalThis.Number(object.lostFrameCount)
        : isSet(object.lost_frame_count)
        ? globalThis.Number(object.lost_frame_count)
        : 0,
      latencyNs: isSet(object.latencyNs)
        ? Long.fromValue(object.latencyNs)
        : isSet(object.latency_ns)
        ? Long.fromValue(object.latency_ns)
        : Long.UZERO,
    };
  },

  toJSON(message: SamTrackingDay): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = samTrackingStatusToJSON(message.status);
    }
    if (message.state !== 0) {
      obj.state = samTrackingStateToJSON(message.state);
    }
    if (message.bboxX1 !== 0) {
      obj.bboxX1 = message.bboxX1;
    }
    if (message.bboxY1 !== 0) {
      obj.bboxY1 = message.bboxY1;
    }
    if (message.bboxX2 !== 0) {
      obj.bboxX2 = message.bboxX2;
    }
    if (message.bboxY2 !== 0) {
      obj.bboxY2 = message.bboxY2;
    }
    if (message.centroidX !== 0) {
      obj.centroidX = message.centroidX;
    }
    if (message.centroidY !== 0) {
      obj.centroidY = message.centroidY;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.iou !== 0) {
      obj.iou = message.iou;
    }
    if (message.maskRle.length !== 0) {
      obj.maskRle = base64FromBytes(message.maskRle);
    }
    if (message.maskWidth !== 0) {
      obj.maskWidth = Math.round(message.maskWidth);
    }
    if (message.maskHeight !== 0) {
      obj.maskHeight = Math.round(message.maskHeight);
    }
    if (message.maskPixels !== 0) {
      obj.maskPixels = Math.round(message.maskPixels);
    }
    if (message.frame !== undefined) {
      obj.frame = SamTrackingFrameMeta.toJSON(message.frame);
    }
    if (message.kalman !== undefined) {
      obj.kalman = SamTrackingKalmanState.toJSON(message.kalman);
    }
    if (message.lostFrameCount !== 0) {
      obj.lostFrameCount = Math.round(message.lostFrameCount);
    }
    if (!message.latencyNs.equals(Long.UZERO)) {
      obj.latencyNs = (message.latencyNs || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SamTrackingDay>, I>>(base?: I): SamTrackingDay {
    return SamTrackingDay.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SamTrackingDay>, I>>(object: I): SamTrackingDay {
    const message = createBaseSamTrackingDay();
    message.status = object.status ?? 0;
    message.state = object.state ?? 0;
    message.bboxX1 = object.bboxX1 ?? 0;
    message.bboxY1 = object.bboxY1 ?? 0;
    message.bboxX2 = object.bboxX2 ?? 0;
    message.bboxY2 = object.bboxY2 ?? 0;
    message.centroidX = object.centroidX ?? 0;
    message.centroidY = object.centroidY ?? 0;
    message.confidence = object.confidence ?? 0;
    message.iou = object.iou ?? 0;
    message.maskRle = object.maskRle ?? new Uint8Array(0);
    message.maskWidth = object.maskWidth ?? 0;
    message.maskHeight = object.maskHeight ?? 0;
    message.maskPixels = object.maskPixels ?? 0;
    message.frame = (object.frame !== undefined && object.frame !== null)
      ? SamTrackingFrameMeta.fromPartial(object.frame)
      : undefined;
    message.kalman = (object.kalman !== undefined && object.kalman !== null)
      ? SamTrackingKalmanState.fromPartial(object.kalman)
      : undefined;
    message.lostFrameCount = object.lostFrameCount ?? 0;
    message.latencyNs = (object.latencyNs !== undefined && object.latencyNs !== null)
      ? Long.fromValue(object.latencyNs)
      : Long.UZERO;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
