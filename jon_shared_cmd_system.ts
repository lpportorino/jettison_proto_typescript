// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v5.29.2
// source: jon_shared_cmd_system.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  JonGuiDataSystemLocalizations,
  jonGuiDataSystemLocalizationsFromJSON,
  jonGuiDataSystemLocalizationsToJSON,
} from "./jon_shared_data_types";

export interface Root {
  startAll?: StartALl | undefined;
  stopAll?: StopALl | undefined;
  reboot?: Reboot | undefined;
  powerOff?: PowerOff | undefined;
  localization?: SetLocalization | undefined;
  resetConfigs?: ResetConfigs | undefined;
  startRec?: StartRec | undefined;
  stopRec?: StopRec | undefined;
  markRecImportant?: MarkRecImportant | undefined;
  unmarkRecImportant?: UnmarkRecImportant | undefined;
  enterTransport?: EnterTransport | undefined;
  geodesicModeEnable?: EnableGeodesicMode | undefined;
  geodesicModeDisable?: DisableGeodesicMode | undefined;
  saveFactoryDefaults?: SaveFactoryDefaults | undefined;
  wipeUserData?: WipeUserData | undefined;
  stepYear?: StepYear | undefined;
  stepMonth?: StepMonth | undefined;
  stepDay?: StepDay | undefined;
  stepHour?: StepHour | undefined;
  stepMinute?: StepMinute | undefined;
  stepSecond?: StepSecond | undefined;
  enableManualTime?: EnableManualTime | undefined;
  disableManualTime?: DisableManualTime | undefined;
  setTimeZone?: SetTimeZone | undefined;
  stepTimeZone?: StepTimeZone | undefined;
  setTimeAndZone?: SetTimeAndZone | undefined;
}

export interface StartALl {
}

export interface StopALl {
}

export interface Reboot {
}

export interface PowerOff {
}

export interface ResetConfigs {
}

export interface SaveFactoryDefaults {
}

export interface WipeUserData {
}

export interface StartRec {
}

export interface StopRec {
}

export interface MarkRecImportant {
}

export interface UnmarkRecImportant {
}

export interface EnterTransport {
}

export interface EnableGeodesicMode {
}

export interface DisableGeodesicMode {
}

export interface SetLocalization {
  loc: JonGuiDataSystemLocalizations;
}

export interface StepYear {
  /** Positive or negative year offset */
  offset: number;
}

export interface StepMonth {
  /** Positive or negative month offset */
  offset: number;
}

export interface StepDay {
  /** Positive or negative day offset */
  offset: number;
}

export interface StepHour {
  /** Positive or negative hour offset */
  offset: number;
}

export interface StepMinute {
  /** Positive or negative minute offset */
  offset: number;
}

export interface StepSecond {
  /** Positive or negative second offset */
  offset: number;
}

export interface EnableManualTime {
}

export interface DisableManualTime {
}

export interface SetTimeZone {
  zoneId: number;
}

export interface StepTimeZone {
  /** Positive or negative timezone index offset */
  offset: number;
}

export interface SetTimeAndZone {
  timestamp: Long;
  zoneId: number;
}

function createBaseRoot(): Root {
  return {
    startAll: undefined,
    stopAll: undefined,
    reboot: undefined,
    powerOff: undefined,
    localization: undefined,
    resetConfigs: undefined,
    startRec: undefined,
    stopRec: undefined,
    markRecImportant: undefined,
    unmarkRecImportant: undefined,
    enterTransport: undefined,
    geodesicModeEnable: undefined,
    geodesicModeDisable: undefined,
    saveFactoryDefaults: undefined,
    wipeUserData: undefined,
    stepYear: undefined,
    stepMonth: undefined,
    stepDay: undefined,
    stepHour: undefined,
    stepMinute: undefined,
    stepSecond: undefined,
    enableManualTime: undefined,
    disableManualTime: undefined,
    setTimeZone: undefined,
    stepTimeZone: undefined,
    setTimeAndZone: undefined,
  };
}

export const Root: MessageFns<Root> = {
  encode(message: Root, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startAll !== undefined) {
      StartALl.encode(message.startAll, writer.uint32(10).fork()).join();
    }
    if (message.stopAll !== undefined) {
      StopALl.encode(message.stopAll, writer.uint32(18).fork()).join();
    }
    if (message.reboot !== undefined) {
      Reboot.encode(message.reboot, writer.uint32(26).fork()).join();
    }
    if (message.powerOff !== undefined) {
      PowerOff.encode(message.powerOff, writer.uint32(34).fork()).join();
    }
    if (message.localization !== undefined) {
      SetLocalization.encode(message.localization, writer.uint32(42).fork()).join();
    }
    if (message.resetConfigs !== undefined) {
      ResetConfigs.encode(message.resetConfigs, writer.uint32(50).fork()).join();
    }
    if (message.startRec !== undefined) {
      StartRec.encode(message.startRec, writer.uint32(58).fork()).join();
    }
    if (message.stopRec !== undefined) {
      StopRec.encode(message.stopRec, writer.uint32(66).fork()).join();
    }
    if (message.markRecImportant !== undefined) {
      MarkRecImportant.encode(message.markRecImportant, writer.uint32(74).fork()).join();
    }
    if (message.unmarkRecImportant !== undefined) {
      UnmarkRecImportant.encode(message.unmarkRecImportant, writer.uint32(82).fork()).join();
    }
    if (message.enterTransport !== undefined) {
      EnterTransport.encode(message.enterTransport, writer.uint32(90).fork()).join();
    }
    if (message.geodesicModeEnable !== undefined) {
      EnableGeodesicMode.encode(message.geodesicModeEnable, writer.uint32(98).fork()).join();
    }
    if (message.geodesicModeDisable !== undefined) {
      DisableGeodesicMode.encode(message.geodesicModeDisable, writer.uint32(106).fork()).join();
    }
    if (message.saveFactoryDefaults !== undefined) {
      SaveFactoryDefaults.encode(message.saveFactoryDefaults, writer.uint32(114).fork()).join();
    }
    if (message.wipeUserData !== undefined) {
      WipeUserData.encode(message.wipeUserData, writer.uint32(122).fork()).join();
    }
    if (message.stepYear !== undefined) {
      StepYear.encode(message.stepYear, writer.uint32(130).fork()).join();
    }
    if (message.stepMonth !== undefined) {
      StepMonth.encode(message.stepMonth, writer.uint32(138).fork()).join();
    }
    if (message.stepDay !== undefined) {
      StepDay.encode(message.stepDay, writer.uint32(146).fork()).join();
    }
    if (message.stepHour !== undefined) {
      StepHour.encode(message.stepHour, writer.uint32(154).fork()).join();
    }
    if (message.stepMinute !== undefined) {
      StepMinute.encode(message.stepMinute, writer.uint32(162).fork()).join();
    }
    if (message.stepSecond !== undefined) {
      StepSecond.encode(message.stepSecond, writer.uint32(170).fork()).join();
    }
    if (message.enableManualTime !== undefined) {
      EnableManualTime.encode(message.enableManualTime, writer.uint32(178).fork()).join();
    }
    if (message.disableManualTime !== undefined) {
      DisableManualTime.encode(message.disableManualTime, writer.uint32(186).fork()).join();
    }
    if (message.setTimeZone !== undefined) {
      SetTimeZone.encode(message.setTimeZone, writer.uint32(194).fork()).join();
    }
    if (message.stepTimeZone !== undefined) {
      StepTimeZone.encode(message.stepTimeZone, writer.uint32(202).fork()).join();
    }
    if (message.setTimeAndZone !== undefined) {
      SetTimeAndZone.encode(message.setTimeAndZone, writer.uint32(210).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Root {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startAll = StartALl.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stopAll = StopALl.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reboot = Reboot.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.powerOff = PowerOff.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.localization = SetLocalization.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.resetConfigs = ResetConfigs.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.startRec = StartRec.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.stopRec = StopRec.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.markRecImportant = MarkRecImportant.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.unmarkRecImportant = UnmarkRecImportant.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.enterTransport = EnterTransport.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.geodesicModeEnable = EnableGeodesicMode.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.geodesicModeDisable = DisableGeodesicMode.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.saveFactoryDefaults = SaveFactoryDefaults.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.wipeUserData = WipeUserData.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.stepYear = StepYear.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.stepMonth = StepMonth.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.stepDay = StepDay.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.stepHour = StepHour.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.stepMinute = StepMinute.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.stepSecond = StepSecond.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.enableManualTime = EnableManualTime.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.disableManualTime = DisableManualTime.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.setTimeZone = SetTimeZone.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.stepTimeZone = StepTimeZone.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.setTimeAndZone = SetTimeAndZone.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Root {
    return {
      startAll: isSet(object.startAll) ? StartALl.fromJSON(object.startAll) : undefined,
      stopAll: isSet(object.stopAll) ? StopALl.fromJSON(object.stopAll) : undefined,
      reboot: isSet(object.reboot) ? Reboot.fromJSON(object.reboot) : undefined,
      powerOff: isSet(object.powerOff) ? PowerOff.fromJSON(object.powerOff) : undefined,
      localization: isSet(object.localization) ? SetLocalization.fromJSON(object.localization) : undefined,
      resetConfigs: isSet(object.resetConfigs) ? ResetConfigs.fromJSON(object.resetConfigs) : undefined,
      startRec: isSet(object.startRec) ? StartRec.fromJSON(object.startRec) : undefined,
      stopRec: isSet(object.stopRec) ? StopRec.fromJSON(object.stopRec) : undefined,
      markRecImportant: isSet(object.markRecImportant) ? MarkRecImportant.fromJSON(object.markRecImportant) : undefined,
      unmarkRecImportant: isSet(object.unmarkRecImportant)
        ? UnmarkRecImportant.fromJSON(object.unmarkRecImportant)
        : undefined,
      enterTransport: isSet(object.enterTransport) ? EnterTransport.fromJSON(object.enterTransport) : undefined,
      geodesicModeEnable: isSet(object.geodesicModeEnable)
        ? EnableGeodesicMode.fromJSON(object.geodesicModeEnable)
        : undefined,
      geodesicModeDisable: isSet(object.geodesicModeDisable)
        ? DisableGeodesicMode.fromJSON(object.geodesicModeDisable)
        : undefined,
      saveFactoryDefaults: isSet(object.saveFactoryDefaults)
        ? SaveFactoryDefaults.fromJSON(object.saveFactoryDefaults)
        : undefined,
      wipeUserData: isSet(object.wipeUserData) ? WipeUserData.fromJSON(object.wipeUserData) : undefined,
      stepYear: isSet(object.stepYear) ? StepYear.fromJSON(object.stepYear) : undefined,
      stepMonth: isSet(object.stepMonth) ? StepMonth.fromJSON(object.stepMonth) : undefined,
      stepDay: isSet(object.stepDay) ? StepDay.fromJSON(object.stepDay) : undefined,
      stepHour: isSet(object.stepHour) ? StepHour.fromJSON(object.stepHour) : undefined,
      stepMinute: isSet(object.stepMinute) ? StepMinute.fromJSON(object.stepMinute) : undefined,
      stepSecond: isSet(object.stepSecond) ? StepSecond.fromJSON(object.stepSecond) : undefined,
      enableManualTime: isSet(object.enableManualTime) ? EnableManualTime.fromJSON(object.enableManualTime) : undefined,
      disableManualTime: isSet(object.disableManualTime)
        ? DisableManualTime.fromJSON(object.disableManualTime)
        : undefined,
      setTimeZone: isSet(object.setTimeZone) ? SetTimeZone.fromJSON(object.setTimeZone) : undefined,
      stepTimeZone: isSet(object.stepTimeZone) ? StepTimeZone.fromJSON(object.stepTimeZone) : undefined,
      setTimeAndZone: isSet(object.setTimeAndZone) ? SetTimeAndZone.fromJSON(object.setTimeAndZone) : undefined,
    };
  },

  toJSON(message: Root): unknown {
    const obj: any = {};
    if (message.startAll !== undefined) {
      obj.startAll = StartALl.toJSON(message.startAll);
    }
    if (message.stopAll !== undefined) {
      obj.stopAll = StopALl.toJSON(message.stopAll);
    }
    if (message.reboot !== undefined) {
      obj.reboot = Reboot.toJSON(message.reboot);
    }
    if (message.powerOff !== undefined) {
      obj.powerOff = PowerOff.toJSON(message.powerOff);
    }
    if (message.localization !== undefined) {
      obj.localization = SetLocalization.toJSON(message.localization);
    }
    if (message.resetConfigs !== undefined) {
      obj.resetConfigs = ResetConfigs.toJSON(message.resetConfigs);
    }
    if (message.startRec !== undefined) {
      obj.startRec = StartRec.toJSON(message.startRec);
    }
    if (message.stopRec !== undefined) {
      obj.stopRec = StopRec.toJSON(message.stopRec);
    }
    if (message.markRecImportant !== undefined) {
      obj.markRecImportant = MarkRecImportant.toJSON(message.markRecImportant);
    }
    if (message.unmarkRecImportant !== undefined) {
      obj.unmarkRecImportant = UnmarkRecImportant.toJSON(message.unmarkRecImportant);
    }
    if (message.enterTransport !== undefined) {
      obj.enterTransport = EnterTransport.toJSON(message.enterTransport);
    }
    if (message.geodesicModeEnable !== undefined) {
      obj.geodesicModeEnable = EnableGeodesicMode.toJSON(message.geodesicModeEnable);
    }
    if (message.geodesicModeDisable !== undefined) {
      obj.geodesicModeDisable = DisableGeodesicMode.toJSON(message.geodesicModeDisable);
    }
    if (message.saveFactoryDefaults !== undefined) {
      obj.saveFactoryDefaults = SaveFactoryDefaults.toJSON(message.saveFactoryDefaults);
    }
    if (message.wipeUserData !== undefined) {
      obj.wipeUserData = WipeUserData.toJSON(message.wipeUserData);
    }
    if (message.stepYear !== undefined) {
      obj.stepYear = StepYear.toJSON(message.stepYear);
    }
    if (message.stepMonth !== undefined) {
      obj.stepMonth = StepMonth.toJSON(message.stepMonth);
    }
    if (message.stepDay !== undefined) {
      obj.stepDay = StepDay.toJSON(message.stepDay);
    }
    if (message.stepHour !== undefined) {
      obj.stepHour = StepHour.toJSON(message.stepHour);
    }
    if (message.stepMinute !== undefined) {
      obj.stepMinute = StepMinute.toJSON(message.stepMinute);
    }
    if (message.stepSecond !== undefined) {
      obj.stepSecond = StepSecond.toJSON(message.stepSecond);
    }
    if (message.enableManualTime !== undefined) {
      obj.enableManualTime = EnableManualTime.toJSON(message.enableManualTime);
    }
    if (message.disableManualTime !== undefined) {
      obj.disableManualTime = DisableManualTime.toJSON(message.disableManualTime);
    }
    if (message.setTimeZone !== undefined) {
      obj.setTimeZone = SetTimeZone.toJSON(message.setTimeZone);
    }
    if (message.stepTimeZone !== undefined) {
      obj.stepTimeZone = StepTimeZone.toJSON(message.stepTimeZone);
    }
    if (message.setTimeAndZone !== undefined) {
      obj.setTimeAndZone = SetTimeAndZone.toJSON(message.setTimeAndZone);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Root>, I>>(base?: I): Root {
    return Root.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Root>, I>>(object: I): Root {
    const message = createBaseRoot();
    message.startAll = (object.startAll !== undefined && object.startAll !== null)
      ? StartALl.fromPartial(object.startAll)
      : undefined;
    message.stopAll = (object.stopAll !== undefined && object.stopAll !== null)
      ? StopALl.fromPartial(object.stopAll)
      : undefined;
    message.reboot = (object.reboot !== undefined && object.reboot !== null)
      ? Reboot.fromPartial(object.reboot)
      : undefined;
    message.powerOff = (object.powerOff !== undefined && object.powerOff !== null)
      ? PowerOff.fromPartial(object.powerOff)
      : undefined;
    message.localization = (object.localization !== undefined && object.localization !== null)
      ? SetLocalization.fromPartial(object.localization)
      : undefined;
    message.resetConfigs = (object.resetConfigs !== undefined && object.resetConfigs !== null)
      ? ResetConfigs.fromPartial(object.resetConfigs)
      : undefined;
    message.startRec = (object.startRec !== undefined && object.startRec !== null)
      ? StartRec.fromPartial(object.startRec)
      : undefined;
    message.stopRec = (object.stopRec !== undefined && object.stopRec !== null)
      ? StopRec.fromPartial(object.stopRec)
      : undefined;
    message.markRecImportant = (object.markRecImportant !== undefined && object.markRecImportant !== null)
      ? MarkRecImportant.fromPartial(object.markRecImportant)
      : undefined;
    message.unmarkRecImportant = (object.unmarkRecImportant !== undefined && object.unmarkRecImportant !== null)
      ? UnmarkRecImportant.fromPartial(object.unmarkRecImportant)
      : undefined;
    message.enterTransport = (object.enterTransport !== undefined && object.enterTransport !== null)
      ? EnterTransport.fromPartial(object.enterTransport)
      : undefined;
    message.geodesicModeEnable = (object.geodesicModeEnable !== undefined && object.geodesicModeEnable !== null)
      ? EnableGeodesicMode.fromPartial(object.geodesicModeEnable)
      : undefined;
    message.geodesicModeDisable = (object.geodesicModeDisable !== undefined && object.geodesicModeDisable !== null)
      ? DisableGeodesicMode.fromPartial(object.geodesicModeDisable)
      : undefined;
    message.saveFactoryDefaults = (object.saveFactoryDefaults !== undefined && object.saveFactoryDefaults !== null)
      ? SaveFactoryDefaults.fromPartial(object.saveFactoryDefaults)
      : undefined;
    message.wipeUserData = (object.wipeUserData !== undefined && object.wipeUserData !== null)
      ? WipeUserData.fromPartial(object.wipeUserData)
      : undefined;
    message.stepYear = (object.stepYear !== undefined && object.stepYear !== null)
      ? StepYear.fromPartial(object.stepYear)
      : undefined;
    message.stepMonth = (object.stepMonth !== undefined && object.stepMonth !== null)
      ? StepMonth.fromPartial(object.stepMonth)
      : undefined;
    message.stepDay = (object.stepDay !== undefined && object.stepDay !== null)
      ? StepDay.fromPartial(object.stepDay)
      : undefined;
    message.stepHour = (object.stepHour !== undefined && object.stepHour !== null)
      ? StepHour.fromPartial(object.stepHour)
      : undefined;
    message.stepMinute = (object.stepMinute !== undefined && object.stepMinute !== null)
      ? StepMinute.fromPartial(object.stepMinute)
      : undefined;
    message.stepSecond = (object.stepSecond !== undefined && object.stepSecond !== null)
      ? StepSecond.fromPartial(object.stepSecond)
      : undefined;
    message.enableManualTime = (object.enableManualTime !== undefined && object.enableManualTime !== null)
      ? EnableManualTime.fromPartial(object.enableManualTime)
      : undefined;
    message.disableManualTime = (object.disableManualTime !== undefined && object.disableManualTime !== null)
      ? DisableManualTime.fromPartial(object.disableManualTime)
      : undefined;
    message.setTimeZone = (object.setTimeZone !== undefined && object.setTimeZone !== null)
      ? SetTimeZone.fromPartial(object.setTimeZone)
      : undefined;
    message.stepTimeZone = (object.stepTimeZone !== undefined && object.stepTimeZone !== null)
      ? StepTimeZone.fromPartial(object.stepTimeZone)
      : undefined;
    message.setTimeAndZone = (object.setTimeAndZone !== undefined && object.setTimeAndZone !== null)
      ? SetTimeAndZone.fromPartial(object.setTimeAndZone)
      : undefined;
    return message;
  },
};

function createBaseStartALl(): StartALl {
  return {};
}

export const StartALl: MessageFns<StartALl> = {
  encode(_: StartALl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartALl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartALl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StartALl {
    return {};
  },

  toJSON(_: StartALl): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StartALl>, I>>(base?: I): StartALl {
    return StartALl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartALl>, I>>(_: I): StartALl {
    const message = createBaseStartALl();
    return message;
  },
};

function createBaseStopALl(): StopALl {
  return {};
}

export const StopALl: MessageFns<StopALl> = {
  encode(_: StopALl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopALl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopALl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StopALl {
    return {};
  },

  toJSON(_: StopALl): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StopALl>, I>>(base?: I): StopALl {
    return StopALl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StopALl>, I>>(_: I): StopALl {
    const message = createBaseStopALl();
    return message;
  },
};

function createBaseReboot(): Reboot {
  return {};
}

export const Reboot: MessageFns<Reboot> = {
  encode(_: Reboot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reboot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReboot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Reboot {
    return {};
  },

  toJSON(_: Reboot): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Reboot>, I>>(base?: I): Reboot {
    return Reboot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Reboot>, I>>(_: I): Reboot {
    const message = createBaseReboot();
    return message;
  },
};

function createBasePowerOff(): PowerOff {
  return {};
}

export const PowerOff: MessageFns<PowerOff> = {
  encode(_: PowerOff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PowerOff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePowerOff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PowerOff {
    return {};
  },

  toJSON(_: PowerOff): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PowerOff>, I>>(base?: I): PowerOff {
    return PowerOff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PowerOff>, I>>(_: I): PowerOff {
    const message = createBasePowerOff();
    return message;
  },
};

function createBaseResetConfigs(): ResetConfigs {
  return {};
}

export const ResetConfigs: MessageFns<ResetConfigs> = {
  encode(_: ResetConfigs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetConfigs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetConfigs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResetConfigs {
    return {};
  },

  toJSON(_: ResetConfigs): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetConfigs>, I>>(base?: I): ResetConfigs {
    return ResetConfigs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetConfigs>, I>>(_: I): ResetConfigs {
    const message = createBaseResetConfigs();
    return message;
  },
};

function createBaseSaveFactoryDefaults(): SaveFactoryDefaults {
  return {};
}

export const SaveFactoryDefaults: MessageFns<SaveFactoryDefaults> = {
  encode(_: SaveFactoryDefaults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SaveFactoryDefaults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveFactoryDefaults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SaveFactoryDefaults {
    return {};
  },

  toJSON(_: SaveFactoryDefaults): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SaveFactoryDefaults>, I>>(base?: I): SaveFactoryDefaults {
    return SaveFactoryDefaults.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SaveFactoryDefaults>, I>>(_: I): SaveFactoryDefaults {
    const message = createBaseSaveFactoryDefaults();
    return message;
  },
};

function createBaseWipeUserData(): WipeUserData {
  return {};
}

export const WipeUserData: MessageFns<WipeUserData> = {
  encode(_: WipeUserData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WipeUserData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWipeUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WipeUserData {
    return {};
  },

  toJSON(_: WipeUserData): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<WipeUserData>, I>>(base?: I): WipeUserData {
    return WipeUserData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WipeUserData>, I>>(_: I): WipeUserData {
    const message = createBaseWipeUserData();
    return message;
  },
};

function createBaseStartRec(): StartRec {
  return {};
}

export const StartRec: MessageFns<StartRec> = {
  encode(_: StartRec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartRec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StartRec {
    return {};
  },

  toJSON(_: StartRec): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StartRec>, I>>(base?: I): StartRec {
    return StartRec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartRec>, I>>(_: I): StartRec {
    const message = createBaseStartRec();
    return message;
  },
};

function createBaseStopRec(): StopRec {
  return {};
}

export const StopRec: MessageFns<StopRec> = {
  encode(_: StopRec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopRec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopRec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StopRec {
    return {};
  },

  toJSON(_: StopRec): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StopRec>, I>>(base?: I): StopRec {
    return StopRec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StopRec>, I>>(_: I): StopRec {
    const message = createBaseStopRec();
    return message;
  },
};

function createBaseMarkRecImportant(): MarkRecImportant {
  return {};
}

export const MarkRecImportant: MessageFns<MarkRecImportant> = {
  encode(_: MarkRecImportant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarkRecImportant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkRecImportant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MarkRecImportant {
    return {};
  },

  toJSON(_: MarkRecImportant): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkRecImportant>, I>>(base?: I): MarkRecImportant {
    return MarkRecImportant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkRecImportant>, I>>(_: I): MarkRecImportant {
    const message = createBaseMarkRecImportant();
    return message;
  },
};

function createBaseUnmarkRecImportant(): UnmarkRecImportant {
  return {};
}

export const UnmarkRecImportant: MessageFns<UnmarkRecImportant> = {
  encode(_: UnmarkRecImportant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnmarkRecImportant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnmarkRecImportant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UnmarkRecImportant {
    return {};
  },

  toJSON(_: UnmarkRecImportant): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UnmarkRecImportant>, I>>(base?: I): UnmarkRecImportant {
    return UnmarkRecImportant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnmarkRecImportant>, I>>(_: I): UnmarkRecImportant {
    const message = createBaseUnmarkRecImportant();
    return message;
  },
};

function createBaseEnterTransport(): EnterTransport {
  return {};
}

export const EnterTransport: MessageFns<EnterTransport> = {
  encode(_: EnterTransport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnterTransport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterTransport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EnterTransport {
    return {};
  },

  toJSON(_: EnterTransport): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EnterTransport>, I>>(base?: I): EnterTransport {
    return EnterTransport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnterTransport>, I>>(_: I): EnterTransport {
    const message = createBaseEnterTransport();
    return message;
  },
};

function createBaseEnableGeodesicMode(): EnableGeodesicMode {
  return {};
}

export const EnableGeodesicMode: MessageFns<EnableGeodesicMode> = {
  encode(_: EnableGeodesicMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnableGeodesicMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnableGeodesicMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EnableGeodesicMode {
    return {};
  },

  toJSON(_: EnableGeodesicMode): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EnableGeodesicMode>, I>>(base?: I): EnableGeodesicMode {
    return EnableGeodesicMode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnableGeodesicMode>, I>>(_: I): EnableGeodesicMode {
    const message = createBaseEnableGeodesicMode();
    return message;
  },
};

function createBaseDisableGeodesicMode(): DisableGeodesicMode {
  return {};
}

export const DisableGeodesicMode: MessageFns<DisableGeodesicMode> = {
  encode(_: DisableGeodesicMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisableGeodesicMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisableGeodesicMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DisableGeodesicMode {
    return {};
  },

  toJSON(_: DisableGeodesicMode): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DisableGeodesicMode>, I>>(base?: I): DisableGeodesicMode {
    return DisableGeodesicMode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisableGeodesicMode>, I>>(_: I): DisableGeodesicMode {
    const message = createBaseDisableGeodesicMode();
    return message;
  },
};

function createBaseSetLocalization(): SetLocalization {
  return { loc: 0 };
}

export const SetLocalization: MessageFns<SetLocalization> = {
  encode(message: SetLocalization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loc !== 0) {
      writer.uint32(8).int32(message.loc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetLocalization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLocalization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.loc = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLocalization {
    return { loc: isSet(object.loc) ? jonGuiDataSystemLocalizationsFromJSON(object.loc) : 0 };
  },

  toJSON(message: SetLocalization): unknown {
    const obj: any = {};
    if (message.loc !== 0) {
      obj.loc = jonGuiDataSystemLocalizationsToJSON(message.loc);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetLocalization>, I>>(base?: I): SetLocalization {
    return SetLocalization.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetLocalization>, I>>(object: I): SetLocalization {
    const message = createBaseSetLocalization();
    message.loc = object.loc ?? 0;
    return message;
  },
};

function createBaseStepYear(): StepYear {
  return { offset: 0 };
}

export const StepYear: MessageFns<StepYear> = {
  encode(message: StepYear, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepYear {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepYear();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StepYear {
    return { offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0 };
  },

  toJSON(message: StepYear): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StepYear>, I>>(base?: I): StepYear {
    return StepYear.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepYear>, I>>(object: I): StepYear {
    const message = createBaseStepYear();
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseStepMonth(): StepMonth {
  return { offset: 0 };
}

export const StepMonth: MessageFns<StepMonth> = {
  encode(message: StepMonth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepMonth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepMonth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StepMonth {
    return { offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0 };
  },

  toJSON(message: StepMonth): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StepMonth>, I>>(base?: I): StepMonth {
    return StepMonth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepMonth>, I>>(object: I): StepMonth {
    const message = createBaseStepMonth();
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseStepDay(): StepDay {
  return { offset: 0 };
}

export const StepDay: MessageFns<StepDay> = {
  encode(message: StepDay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepDay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepDay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StepDay {
    return { offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0 };
  },

  toJSON(message: StepDay): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StepDay>, I>>(base?: I): StepDay {
    return StepDay.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepDay>, I>>(object: I): StepDay {
    const message = createBaseStepDay();
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseStepHour(): StepHour {
  return { offset: 0 };
}

export const StepHour: MessageFns<StepHour> = {
  encode(message: StepHour, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepHour {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepHour();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StepHour {
    return { offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0 };
  },

  toJSON(message: StepHour): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StepHour>, I>>(base?: I): StepHour {
    return StepHour.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepHour>, I>>(object: I): StepHour {
    const message = createBaseStepHour();
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseStepMinute(): StepMinute {
  return { offset: 0 };
}

export const StepMinute: MessageFns<StepMinute> = {
  encode(message: StepMinute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepMinute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepMinute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StepMinute {
    return { offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0 };
  },

  toJSON(message: StepMinute): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StepMinute>, I>>(base?: I): StepMinute {
    return StepMinute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepMinute>, I>>(object: I): StepMinute {
    const message = createBaseStepMinute();
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseStepSecond(): StepSecond {
  return { offset: 0 };
}

export const StepSecond: MessageFns<StepSecond> = {
  encode(message: StepSecond, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepSecond {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepSecond();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StepSecond {
    return { offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0 };
  },

  toJSON(message: StepSecond): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StepSecond>, I>>(base?: I): StepSecond {
    return StepSecond.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepSecond>, I>>(object: I): StepSecond {
    const message = createBaseStepSecond();
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseEnableManualTime(): EnableManualTime {
  return {};
}

export const EnableManualTime: MessageFns<EnableManualTime> = {
  encode(_: EnableManualTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnableManualTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnableManualTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EnableManualTime {
    return {};
  },

  toJSON(_: EnableManualTime): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EnableManualTime>, I>>(base?: I): EnableManualTime {
    return EnableManualTime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnableManualTime>, I>>(_: I): EnableManualTime {
    const message = createBaseEnableManualTime();
    return message;
  },
};

function createBaseDisableManualTime(): DisableManualTime {
  return {};
}

export const DisableManualTime: MessageFns<DisableManualTime> = {
  encode(_: DisableManualTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisableManualTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisableManualTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DisableManualTime {
    return {};
  },

  toJSON(_: DisableManualTime): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DisableManualTime>, I>>(base?: I): DisableManualTime {
    return DisableManualTime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisableManualTime>, I>>(_: I): DisableManualTime {
    const message = createBaseDisableManualTime();
    return message;
  },
};

function createBaseSetTimeZone(): SetTimeZone {
  return { zoneId: 0 };
}

export const SetTimeZone: MessageFns<SetTimeZone> = {
  encode(message: SetTimeZone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.zoneId !== 0) {
      writer.uint32(8).int32(message.zoneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetTimeZone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetTimeZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.zoneId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetTimeZone {
    return { zoneId: isSet(object.zoneId) ? globalThis.Number(object.zoneId) : 0 };
  },

  toJSON(message: SetTimeZone): unknown {
    const obj: any = {};
    if (message.zoneId !== 0) {
      obj.zoneId = Math.round(message.zoneId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetTimeZone>, I>>(base?: I): SetTimeZone {
    return SetTimeZone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetTimeZone>, I>>(object: I): SetTimeZone {
    const message = createBaseSetTimeZone();
    message.zoneId = object.zoneId ?? 0;
    return message;
  },
};

function createBaseStepTimeZone(): StepTimeZone {
  return { offset: 0 };
}

export const StepTimeZone: MessageFns<StepTimeZone> = {
  encode(message: StepTimeZone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepTimeZone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepTimeZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StepTimeZone {
    return { offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0 };
  },

  toJSON(message: StepTimeZone): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StepTimeZone>, I>>(base?: I): StepTimeZone {
    return StepTimeZone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepTimeZone>, I>>(object: I): StepTimeZone {
    const message = createBaseStepTimeZone();
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseSetTimeAndZone(): SetTimeAndZone {
  return { timestamp: Long.ZERO, zoneId: 0 };
}

export const SetTimeAndZone: MessageFns<SetTimeAndZone> = {
  encode(message: SetTimeAndZone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.timestamp.toString());
    }
    if (message.zoneId !== 0) {
      writer.uint32(16).int32(message.zoneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetTimeAndZone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetTimeAndZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.zoneId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetTimeAndZone {
    return {
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
      zoneId: isSet(object.zoneId) ? globalThis.Number(object.zoneId) : 0,
    };
  },

  toJSON(message: SetTimeAndZone): unknown {
    const obj: any = {};
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    if (message.zoneId !== 0) {
      obj.zoneId = Math.round(message.zoneId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetTimeAndZone>, I>>(base?: I): SetTimeAndZone {
    return SetTimeAndZone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetTimeAndZone>, I>>(object: I): SetTimeAndZone {
    const message = createBaseSetTimeAndZone();
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    message.zoneId = object.zoneId ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
