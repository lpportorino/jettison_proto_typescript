// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v5.29.2
// source: opaque/sam_tracking_common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

/**
 * SAM tracking state machine states.
 * State transitions: IDLE → STARTING → TRACKING ⇄ OCCLUDED → LOST
 */
export enum SamTrackingState {
  SAM_TRACKING_STATE_UNSPECIFIED = 0,
  /** SAM_TRACKING_STATE_IDLE - Not tracking, awaiting start */
  SAM_TRACKING_STATE_IDLE = 1,
  /** SAM_TRACKING_STATE_STARTING - Initial prompt received, warming up */
  SAM_TRACKING_STATE_STARTING = 2,
  /** SAM_TRACKING_STATE_TRACKING - Normal tracking with valid masks */
  SAM_TRACKING_STATE_TRACKING = 3,
  /** SAM_TRACKING_STATE_OCCLUDED - Low confidence, using Kalman prediction */
  SAM_TRACKING_STATE_OCCLUDED = 4,
  /** SAM_TRACKING_STATE_LOST - Tracking lost (max_occluded_frames exceeded) */
  SAM_TRACKING_STATE_LOST = 5,
  UNRECOGNIZED = -1,
}

export function samTrackingStateFromJSON(object: any): SamTrackingState {
  switch (object) {
    case 0:
    case "SAM_TRACKING_STATE_UNSPECIFIED":
      return SamTrackingState.SAM_TRACKING_STATE_UNSPECIFIED;
    case 1:
    case "SAM_TRACKING_STATE_IDLE":
      return SamTrackingState.SAM_TRACKING_STATE_IDLE;
    case 2:
    case "SAM_TRACKING_STATE_STARTING":
      return SamTrackingState.SAM_TRACKING_STATE_STARTING;
    case 3:
    case "SAM_TRACKING_STATE_TRACKING":
      return SamTrackingState.SAM_TRACKING_STATE_TRACKING;
    case 4:
    case "SAM_TRACKING_STATE_OCCLUDED":
      return SamTrackingState.SAM_TRACKING_STATE_OCCLUDED;
    case 5:
    case "SAM_TRACKING_STATE_LOST":
      return SamTrackingState.SAM_TRACKING_STATE_LOST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SamTrackingState.UNRECOGNIZED;
  }
}

export function samTrackingStateToJSON(object: SamTrackingState): string {
  switch (object) {
    case SamTrackingState.SAM_TRACKING_STATE_UNSPECIFIED:
      return "SAM_TRACKING_STATE_UNSPECIFIED";
    case SamTrackingState.SAM_TRACKING_STATE_IDLE:
      return "SAM_TRACKING_STATE_IDLE";
    case SamTrackingState.SAM_TRACKING_STATE_STARTING:
      return "SAM_TRACKING_STATE_STARTING";
    case SamTrackingState.SAM_TRACKING_STATE_TRACKING:
      return "SAM_TRACKING_STATE_TRACKING";
    case SamTrackingState.SAM_TRACKING_STATE_OCCLUDED:
      return "SAM_TRACKING_STATE_OCCLUDED";
    case SamTrackingState.SAM_TRACKING_STATE_LOST:
      return "SAM_TRACKING_STATE_LOST";
    case SamTrackingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** SAM tracking tick result status codes. */
export enum SamTrackingStatus {
  SAM_TRACKING_STATUS_UNSPECIFIED = 0,
  /** SAM_TRACKING_STATUS_OK - Successful tracking iteration */
  SAM_TRACKING_STATUS_OK = 1,
  /** SAM_TRACKING_STATUS_NOT_READY - Engine/IPC not initialized */
  SAM_TRACKING_STATUS_NOT_READY = 2,
  /** SAM_TRACKING_STATUS_NOT_STARTED - Tracking not started (awaiting start command) */
  SAM_TRACKING_STATUS_NOT_STARTED = 3,
  /** SAM_TRACKING_STATUS_IPC_TIMEOUT - CUDA IPC read timeout */
  SAM_TRACKING_STATUS_IPC_TIMEOUT = 4,
  /** SAM_TRACKING_STATUS_INFER_FAILED - TensorRT inference failed */
  SAM_TRACKING_STATUS_INFER_FAILED = 5,
  /** SAM_TRACKING_STATUS_LOST - Object tracking lost */
  SAM_TRACKING_STATUS_LOST = 6,
  UNRECOGNIZED = -1,
}

export function samTrackingStatusFromJSON(object: any): SamTrackingStatus {
  switch (object) {
    case 0:
    case "SAM_TRACKING_STATUS_UNSPECIFIED":
      return SamTrackingStatus.SAM_TRACKING_STATUS_UNSPECIFIED;
    case 1:
    case "SAM_TRACKING_STATUS_OK":
      return SamTrackingStatus.SAM_TRACKING_STATUS_OK;
    case 2:
    case "SAM_TRACKING_STATUS_NOT_READY":
      return SamTrackingStatus.SAM_TRACKING_STATUS_NOT_READY;
    case 3:
    case "SAM_TRACKING_STATUS_NOT_STARTED":
      return SamTrackingStatus.SAM_TRACKING_STATUS_NOT_STARTED;
    case 4:
    case "SAM_TRACKING_STATUS_IPC_TIMEOUT":
      return SamTrackingStatus.SAM_TRACKING_STATUS_IPC_TIMEOUT;
    case 5:
    case "SAM_TRACKING_STATUS_INFER_FAILED":
      return SamTrackingStatus.SAM_TRACKING_STATUS_INFER_FAILED;
    case 6:
    case "SAM_TRACKING_STATUS_LOST":
      return SamTrackingStatus.SAM_TRACKING_STATUS_LOST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SamTrackingStatus.UNRECOGNIZED;
  }
}

export function samTrackingStatusToJSON(object: SamTrackingStatus): string {
  switch (object) {
    case SamTrackingStatus.SAM_TRACKING_STATUS_UNSPECIFIED:
      return "SAM_TRACKING_STATUS_UNSPECIFIED";
    case SamTrackingStatus.SAM_TRACKING_STATUS_OK:
      return "SAM_TRACKING_STATUS_OK";
    case SamTrackingStatus.SAM_TRACKING_STATUS_NOT_READY:
      return "SAM_TRACKING_STATUS_NOT_READY";
    case SamTrackingStatus.SAM_TRACKING_STATUS_NOT_STARTED:
      return "SAM_TRACKING_STATUS_NOT_STARTED";
    case SamTrackingStatus.SAM_TRACKING_STATUS_IPC_TIMEOUT:
      return "SAM_TRACKING_STATUS_IPC_TIMEOUT";
    case SamTrackingStatus.SAM_TRACKING_STATUS_INFER_FAILED:
      return "SAM_TRACKING_STATUS_INFER_FAILED";
    case SamTrackingStatus.SAM_TRACKING_STATUS_LOST:
      return "SAM_TRACKING_STATUS_LOST";
    case SamTrackingStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Frame metadata for SAM tracking correlation. */
export interface SamTrackingFrameMeta {
  /** Presentation timestamp (nanoseconds) */
  ptsNs: Long;
  /** Capture timestamp (nanoseconds) */
  captureTimeNs: Long;
  /** Frame generation counter (for CUDA IPC correlation) */
  generation: number;
  /** Correlation timestamp (CLOCK_MONOTONIC, microseconds) - matches CvMeta pattern */
  captureMonotonicUs: Long;
}

/** Kalman filter state for visualization and debugging. */
export interface SamTrackingKalmanState {
  /** Predicted centroid position (NDC ) */
  predictedX: number;
  predictedY: number;
  /** Velocity estimate (NDC/second) */
  velocityX: number;
  velocityY: number;
}

function createBaseSamTrackingFrameMeta(): SamTrackingFrameMeta {
  return { ptsNs: Long.UZERO, captureTimeNs: Long.UZERO, generation: 0, captureMonotonicUs: Long.UZERO };
}

export const SamTrackingFrameMeta: MessageFns<SamTrackingFrameMeta> = {
  encode(message: SamTrackingFrameMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.ptsNs.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.ptsNs.toString());
    }
    if (!message.captureTimeNs.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.captureTimeNs.toString());
    }
    if (message.generation !== 0) {
      writer.uint32(24).uint32(message.generation);
    }
    if (!message.captureMonotonicUs.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.captureMonotonicUs.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SamTrackingFrameMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSamTrackingFrameMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ptsNs = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.captureTimeNs = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.generation = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.captureMonotonicUs = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SamTrackingFrameMeta {
    return {
      ptsNs: isSet(object.ptsNs)
        ? Long.fromValue(object.ptsNs)
        : isSet(object.pts_ns)
        ? Long.fromValue(object.pts_ns)
        : Long.UZERO,
      captureTimeNs: isSet(object.captureTimeNs)
        ? Long.fromValue(object.captureTimeNs)
        : isSet(object.capture_time_ns)
        ? Long.fromValue(object.capture_time_ns)
        : Long.UZERO,
      generation: isSet(object.generation) ? globalThis.Number(object.generation) : 0,
      captureMonotonicUs: isSet(object.captureMonotonicUs)
        ? Long.fromValue(object.captureMonotonicUs)
        : isSet(object.capture_monotonic_us)
        ? Long.fromValue(object.capture_monotonic_us)
        : Long.UZERO,
    };
  },

  toJSON(message: SamTrackingFrameMeta): unknown {
    const obj: any = {};
    if (!message.ptsNs.equals(Long.UZERO)) {
      obj.ptsNs = (message.ptsNs || Long.UZERO).toString();
    }
    if (!message.captureTimeNs.equals(Long.UZERO)) {
      obj.captureTimeNs = (message.captureTimeNs || Long.UZERO).toString();
    }
    if (message.generation !== 0) {
      obj.generation = Math.round(message.generation);
    }
    if (!message.captureMonotonicUs.equals(Long.UZERO)) {
      obj.captureMonotonicUs = (message.captureMonotonicUs || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SamTrackingFrameMeta>, I>>(base?: I): SamTrackingFrameMeta {
    return SamTrackingFrameMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SamTrackingFrameMeta>, I>>(object: I): SamTrackingFrameMeta {
    const message = createBaseSamTrackingFrameMeta();
    message.ptsNs = (object.ptsNs !== undefined && object.ptsNs !== null) ? Long.fromValue(object.ptsNs) : Long.UZERO;
    message.captureTimeNs = (object.captureTimeNs !== undefined && object.captureTimeNs !== null)
      ? Long.fromValue(object.captureTimeNs)
      : Long.UZERO;
    message.generation = object.generation ?? 0;
    message.captureMonotonicUs = (object.captureMonotonicUs !== undefined && object.captureMonotonicUs !== null)
      ? Long.fromValue(object.captureMonotonicUs)
      : Long.UZERO;
    return message;
  },
};

function createBaseSamTrackingKalmanState(): SamTrackingKalmanState {
  return { predictedX: 0, predictedY: 0, velocityX: 0, velocityY: 0 };
}

export const SamTrackingKalmanState: MessageFns<SamTrackingKalmanState> = {
  encode(message: SamTrackingKalmanState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.predictedX !== 0) {
      writer.uint32(9).double(message.predictedX);
    }
    if (message.predictedY !== 0) {
      writer.uint32(17).double(message.predictedY);
    }
    if (message.velocityX !== 0) {
      writer.uint32(25).double(message.velocityX);
    }
    if (message.velocityY !== 0) {
      writer.uint32(33).double(message.velocityY);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SamTrackingKalmanState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSamTrackingKalmanState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.predictedX = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.predictedY = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.velocityX = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.velocityY = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SamTrackingKalmanState {
    return {
      predictedX: isSet(object.predictedX)
        ? globalThis.Number(object.predictedX)
        : isSet(object.predicted_x)
        ? globalThis.Number(object.predicted_x)
        : 0,
      predictedY: isSet(object.predictedY)
        ? globalThis.Number(object.predictedY)
        : isSet(object.predicted_y)
        ? globalThis.Number(object.predicted_y)
        : 0,
      velocityX: isSet(object.velocityX)
        ? globalThis.Number(object.velocityX)
        : isSet(object.velocity_x)
        ? globalThis.Number(object.velocity_x)
        : 0,
      velocityY: isSet(object.velocityY)
        ? globalThis.Number(object.velocityY)
        : isSet(object.velocity_y)
        ? globalThis.Number(object.velocity_y)
        : 0,
    };
  },

  toJSON(message: SamTrackingKalmanState): unknown {
    const obj: any = {};
    if (message.predictedX !== 0) {
      obj.predictedX = message.predictedX;
    }
    if (message.predictedY !== 0) {
      obj.predictedY = message.predictedY;
    }
    if (message.velocityX !== 0) {
      obj.velocityX = message.velocityX;
    }
    if (message.velocityY !== 0) {
      obj.velocityY = message.velocityY;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SamTrackingKalmanState>, I>>(base?: I): SamTrackingKalmanState {
    return SamTrackingKalmanState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SamTrackingKalmanState>, I>>(object: I): SamTrackingKalmanState {
    const message = createBaseSamTrackingKalmanState();
    message.predictedX = object.predictedX ?? 0;
    message.predictedY = object.predictedY ?? 0;
    message.velocityX = object.velocityX ?? 0;
    message.velocityY = object.velocityY ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
